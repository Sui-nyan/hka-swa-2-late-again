generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Change {
    id Int @id
}

model Station {
    // def better_get_station(pattern: str) -> list:
    //     """Returns a list of stations matching the pattern."""
    //     res = get_station(pattern)
    //     res.raise_for_status()
    //     soup = soupify_xml(res.text)
    //     stations = soup.find_all("station")
    //     return [
    //         {
    //             "name": s.get("name"),
    //             "p (platforms)": s.get("p").split("|") if s.get("p") else [], # platforms
    //             "eva (EVA station number)": s.get("eva"), # EVA station number
    //             "ds100 (Station code)": s.get("ds100"), # Station code
    //             "meta (Meta information)": s.get("meta"), # Meta information
    //             "db (isDb?)": s.get("db"), # isDb?
    //         }
    //         for s in stations
    //     ]
    eva        Int       @id
    name       String
    ds100      String    @unique
    meta       Station[] // Eva station numbers of connected stations
    p          String[] // platforms
    isDb       Boolean   @default(false)
    station    Station?  @relation(fields: [stationEva], references: [eva])
    stationEva Int?
}

model Plan {
    id    Int
    stops Stop[]
}

model Stop {
    // def parse_stop(s):
    //     ar = parse_ar(s.ar) if s.ar else None # arrival
    //     dp = parse_dp(s.dp) if s.dp else None # departure
    //     tl = parse_tl(s.tl) if s.tl else None # track/ platform
    //     return {
    //         "id": s.get("id"),
    //         "ar (arrival)": ar,
    //         "dp (departure)": dp,
    //         "tl (trainInfoTuple)": tl
    //     }
    id          Int       @id
    ar          Arrival
    dp          Departure
    tl          TrainInfo @relation(fields: [trainInfoId], references: [id])
    plan        Plan      @relation(fields: [planId], references: [id])
    planId      Int
    trainInfoId Int
}

model Arrival {
    //     def parse_ar(ar: BeautifulSoup):
    //         return {
    //             "pp (plannedPlatform)": ar.get("pp"), # planned platform
    //             "ppth (plannedPath)": ar.get("ppth").split('|'), # planned path
    //             "pt (plannedTime)": ar.get("pt"), # planned time
    //             "l (line)": ar.get("l"), # line
    //         }
    pt     DateTime // planned time
    l      Int // line
    stop   Stop     @relation(fields: [stopId], references: [id])
    stopId Int
}

model Departure {
    //     def parse_dp(dp: BeautifulSoup):
    //         return {
    //             "pp (plannedPlatform)": dp.get("pp"), # planned platform
    //             "ppth (plannedPath)": dp.get("ppth").split('|'), # planned path
    //             "pt (plannedTime)": dp.get("pt"), # planned time
    //             "l (line)": dp.get("l"), # line
    //         }

    stop   Stop     @relation(fields: [stopId], references: [id])
    stopId Int
    pp     String
    ppth   String[]
    pt     DateTime
    l      String
}

model TrainInfo {
    // def parse_tl(tl: BeautifulSoup):
    //     return {
    //         "c (category)": tl.get("c"), # e.g. ICE, RE
    //         "n (trainNumber)": tl.get("n"), # train number
    //         "f (filterFlag)": tl.get("f"), # filter flag
    //         "o (owner)": tl.get("o"), # owner
    //         "t (tripType)": tl.get("t"), # trip type {p,e,z,s,h,n}
    //     }

    id       Int      @id
    stop     Stop     @relation(fields: [stopId], references: [id])
    stopId   Int
    category Category @relation(fields: [c], references: [c])

    c String
    n String
}

model Category {
    c          String      @unique
    trainInfos TrainInfo[]
}
